// Copyright (c) the Codepad contributors. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE.txt in the project root for license information.

#pragma once

/// \file
/// Structs used to render the contents of a \ref codepad::editors::code::contents_region.

#include <tuple>

#include "../buffer.h"
#include "interpretation.h"
#include "view.h"
#include "contents_region.h"

namespace codepad::editors::code {
	/// Indicates that no fragment is produced by the current component.
	struct no_fragment {
	};
	/// A fragment of text that does not contain invalid codepoints, tabs, or linebreaks.
	struct text_fragment {
		/// Default constructor.
		text_fragment() = default;
		/// Initializes all fields of this struct.
		text_fragment(std::basic_string<codepoint> txt, text_theme_specification t) : text(txt), theme(t) {
		}

		std::basic_string<codepoint> text; ///< The text.
		text_theme_specification theme; ///< The theme of this character.
	};
	/// A fragment that contains a single tab character.
	struct tab_fragment {
	};
	/// A fragment that contains an invalid codepoint.
	struct invalid_codepoint_fragment {
		/// Default constructor.
		invalid_codepoint_fragment() = default;
		/// Initializes \ref value.
		explicit invalid_codepoint_fragment(codepoint cp) : value(cp) {
		}

		codepoint value = 0; ///< The byte value of this codepoint.
	};
	/// A fragment that contains a single linebreak.
	struct linebreak_fragment {
		/// Default constructor.
		linebreak_fragment() = default;
		/// Initializes all fields of this struct.
		explicit linebreak_fragment(line_ending le) : type(le) {
		}

		line_ending type = line_ending::none; ///< The type of this linebreak.
	};

	/// Indicates that the next fragment to be rendered is an image.
	struct image_gizmo_fragment {
		// TODO
	};
	/// Indicates that the next fragment to be rendered is a short clip of text.
	struct text_gizmo_fragment {
		/// Default constructor.
		text_gizmo_fragment() = default;
		/// Initializes all fields of this struct.
		text_gizmo_fragment(ui::font_parameters f, str_t str, colord c) : font(f), contents(std::move(str)), color(c) {
		}

		ui::font_parameters font; ///< The font used to render this fragment.
		str_t contents; ///< The contents of this fragment.
		colord color; ///< Color used to render this fragment.
	};

	/// Contains information about a fragment to be rendered.
	using fragment = std::variant<
		no_fragment,
		text_fragment, tab_fragment, invalid_codepoint_fragment, linebreak_fragment,
		image_gizmo_fragment, text_gizmo_fragment
	>;
	/// Holds the result of a step of fragment generation.
	struct fragment_generation_result {
		/// Constructs this struct to indicate that no fragment is generated.
		fragment_generation_result() = default;
		/// Initializes all fields of this struct.
		template <typename T> constexpr fragment_generation_result(T tok, size_t diff) :
			result(std::in_place_type<T>, tok), steps(diff) {
		}

		fragment result; ///< The generated fragment.
		/// The number of characters to move forward. If \ref result holds a \ref no_fragment, then this member
		/// indicates how many characters before the next fragment will be generated.
		size_t steps = 0;

		/// Returns a \ref fragment_generation_result
		inline static fragment_generation_result exhausted() {
			return fragment_generation_result(no_fragment(), std::numeric_limits<size_t>::max());
		}
	};


	/// Used to host additional components of the \ref fragment_generator. Each component must contain the following
	/// three functions: \p generate(), which optionally generates a fragment for the current position;
	/// \p reposition(), which is used to notify this component of the change of the current position; and
	/// \p update(), which is also used to notify of the change of the position, but the position is guaranteed to
	/// move forward and the change is likely small, which may allow for some optimizations.
	template <typename ...Args> struct fragment_generator_component_hub {
	public:
		/// Initializes \ref _components directly.
		template <typename ...InitArgs> explicit fragment_generator_component_hub(InitArgs &&...args) :
			_components(std::forward<InitArgs>(args)...) {
		}

		/// Generates a fragment. If no fragment is generated (i.e., \ref fragment_generation_result::result holds a
		/// \ref no_fragment), \ref fragment_generation_result::steps holds the minimum number of steps before a
		/// fragment would be generated by a component.
		fragment_generation_result generate(size_t position) {
			return _generate_impl(position);
		}
		/// Updates all components.
		void update(size_t oldpos, size_t steps) {
			_update_impl(oldpos, steps, std::make_index_sequence<sizeof...(Args)>());
		}
		/// Repositions all components.
		void reposition(size_t position) {
			_reposition_impl(position, std::make_index_sequence<sizeof...(Args)>());
		}
	protected:
		std::tuple<Args...> _components; ///< The components.

		// TODO is the Count parameter neccessary?
		// https://en.cppreference.com/w/cpp/language/if
		/// Recursive implementation of \ref generate().
		template <size_t Index = 0, size_t Count = sizeof...(Args)> fragment_generation_result _generate_impl(size_t position) {
			if constexpr (Index < Count) {
				fragment_generation_result frag =
					std::get<std::min(Index, Count - 1)>(_components).generate(position);
				if (std::holds_alternative<no_fragment>(frag.result)) { // nope
					size_t steps = frag.steps;
					frag = _generate_impl<Index + 1, Count>(position);
					if (std::holds_alternative<no_fragment>(frag.result)) { // still nope
						frag.steps = std::min(frag.steps, steps);
					}
				}
				return frag;
			} else {
				return fragment_generation_result::exhausted();
			}
		}
		/// Implementation of \ref update().
		template <size_t ...Indices> void _update_impl(
			size_t oldpos, size_t steps, std::index_sequence<Indices...>
		) {
			(..., std::get<Indices>(_components).update(oldpos, steps));
		}
		/// Implementation of \ref reposition().
		template <size_t ...Indices> void _reposition_impl(size_t position, std::index_sequence<Indices...>) {
			(..., std::get<Indices>(_components).reposition(position));
		}
	};

	/// Iterates through a range of text in a \ref interpretation and generates fragments to be rendered.
	template <typename Hub> struct fragment_generator {
		/// The maximum length of a single text fragment.
		constexpr static size_t maximum_text_fragment_length = 100;

		/// Constructs this \ref fragment_generator with the given \ref interpretation and starting position, and the
		/// \ref fragment_generator_component_hub from all other arguments.
		template <typename ...Args> fragment_generator(const interpretation &interp, size_t begpos, Args &&...args) :
			_pos(begpos), _interp(interp), _components(std::forward<Args>(args)...) {
			reposition(_pos);
		}

		/// Returns the fragment for the character or linebreak, and advances to the next character.
		fragment_generation_result generate_and_update() {
			// generate (also _char_it is updated in this step)
			fragment_generation_result res = _components.generate(get_position());
			if (std::holds_alternative<no_fragment>(res.result)) { // generate text
				if (!_char_it.codepoint().is_codepoint_valid()) { // invalid codepoint
					res = fragment_generation_result(
						invalid_codepoint_fragment(_char_it.codepoint().get_codepoint()), 1
					);
					_char_it.next();
				} else if (_char_it.is_linebreak()) { // hard linebreak
					res = fragment_generation_result(linebreak_fragment(_char_it.get_linebreak()), 1);
					_char_it.next();
				} else if (_char_it.codepoint().get_codepoint() == '\t') { // tab
					res = fragment_generation_result(tab_fragment(), 1);
					_char_it.next();
				} else { // otherwise generate a clip of text
					size_t maxsteps = std::min(res.steps, maximum_text_fragment_length);
					maxsteps = std::min(maxsteps, _theme_it.forecast(_pos)); // integrate theme information
					res.steps = 0;
					text_fragment &frag = res.result.emplace<text_fragment>();
					frag.theme = _theme_it.current_theme;
					do {
						frag.text.push_back(_char_it.codepoint().get_codepoint());
						_char_it.next();
						++res.steps;
					} while (
						res.steps < maxsteps &&
						!_char_it.codepoint().ended() &&
						_char_it.codepoint().is_codepoint_valid() &&
						!_char_it.is_linebreak() &&
						_char_it.codepoint().get_codepoint() != '\t'
						);
				}
			} else { // only update _char_it
				if (res.steps == 1) {
					_char_it.next();
				} else if (res.steps > 1) {
					_char_it = _interp.at_character(_pos + res.steps); // TODO room for optimization
				}
			}
			// update everything else
			size_t oldpos = _pos;
			_pos += res.steps;
			_theme_it.move_forward(_pos);
			_components.update(oldpos, res.steps);
			return res;
		}
		/// Resets the current position.
		void reposition(size_t pos) {
			_pos = pos;
			_char_it = _interp.at_character(_pos);
			_theme_it = text_theme_data::char_iterator(_interp.get_text_theme(), _pos);
			_components.reposition(_pos);
		}

		/// Returns the current postiion of this iterator. If this called inside the \p update() method of a
		/// component, then the returned position is that before updating.
		size_t get_position() const {
			return _pos;
		}
	protected:
		/// Forwards the arguments in the given tuple to other constructors.
		template <size_t ...Indices, typename MyArgs> fragment_generator(
			std::index_sequence<Indices...>, MyArgs && tuple
		) : fragment_generator(std::get<Indices>(std::forward<MyArgs>(tuple))...) {
		}

		/// Iterator to the current character in the \ref interpretation.
		interpretation::character_iterator _char_it;
		/// Iterator to the current entry in the \ref text_theme_data that determines the theme of the text.
		text_theme_data::char_iterator _theme_it;
		size_t _pos = 0; ///< The position of character \ref _char_it points to.
		const interpretation &_interp; ///< The associated \ref interpretation.
		Hub _components; ///< Extra components.
	};


	/// A component that inserts soft linebreaks into the document.
	struct soft_linebreak_inserter {
	public:
		/// Initializes this struct with the given \ref soft_linebreak_registry at the given position.
		soft_linebreak_inserter(const soft_linebreak_registry &reg, size_t pos) : _reg(reg) {
			reposition(pos);
		}

		/// Checks and generates a soft linebreak if necessary. \ref _cur_softbreak and \ref _prev_chars are updated
		/// here instead of in \ref update() because this component don't really advance the current position and
		/// will otherwise cause conflicts.
		fragment_generation_result generate(size_t position) {
			if (_cur_softbreak != _reg.end()) {
				size_t nextpos = _prev_chars + _cur_softbreak->length;
				if (position == nextpos) {
					_prev_chars += _cur_softbreak->length;
					++_cur_softbreak;
					return fragment_generation_result(linebreak_fragment(line_ending::none), 0);
				}
				return fragment_generation_result(no_fragment(), nextpos - position);
			}
			return fragment_generation_result::exhausted();
		}
		/// Updates \ref _cur_softbreak according to the given offset.
		void update(size_t oldpos, size_t steps) {
			size_t newpos = oldpos + steps;
			if (steps > 0 && _cur_softbreak != _reg.end()) { // no update needed if not moved
				if (newpos > _prev_chars + _cur_softbreak->length) {
					// reset once the iterator to the next soft linebreak is invalid
					reposition(newpos);
				}
			}
		}
		/// Resets the current position.
		void reposition(size_t position) {
			auto softbreak = _reg.get_softbreak_before_or_at_char(position);
			_prev_chars = softbreak.prev_chars;
			_cur_softbreak = softbreak.entry;
		}
	protected:
		soft_linebreak_registry::iterator _cur_softbreak; ///< Iterator to the next soft linebreak.
		const soft_linebreak_registry &_reg; ///< The registry for soft linebreaks.
		size_t _prev_chars = 0; ///< The number of characters before \ref _cur_softbreak.
	};
	/// A component that jumps to the ends of folded regions and generates corresponding gizmos.
	struct folded_region_skipper {
	public:
		/// Initializes this struct with the given \ref folding_registry at the given position.
		folded_region_skipper(const folding_registry &reg, size_t pos) : _reg(reg) {
			reposition(pos);
		}

		/// Checks and skips the folded region if necessary.
		fragment_generation_result generate(size_t position) {
			if (_cur_region != _reg.end()) {
				if (position >= _region_start) { // jump
					// TODO fragment should be customizable
					return fragment_generation_result(
						text_gizmo_fragment(ui::font_parameters(), "...", colord(0.8, 0.8, 0.8, 1.0)),
						_cur_region->range - (position - _region_start)
					);
				}
				return fragment_generation_result(no_fragment(), _region_start - position);
			}
			return fragment_generation_result::exhausted();
		}
		/// Updates \ref _cur_region according to the given offset.
		void update(size_t oldpos, size_t steps) {
			if (_cur_region != _reg.end()) {
				size_t newpos = oldpos + steps, regionend = _region_start + _cur_region->range;
				if (newpos >= regionend) { // advance to the next region and check again
					++_cur_region;
					if (_cur_region != _reg.end()) {
						_region_start = regionend + _cur_region->gap;
						if (_region_start + _cur_region->range <= newpos) { // nope, still ahead
							reposition(newpos);
						}
					}
				}
			}
		}
		/// Resets the current position.
		void reposition(size_t position) {
			auto region = _reg.find_region_containing_or_first_after_open(position);
			_cur_region = region.entry;
			if (_cur_region != _reg.end()) {
				_region_start = region.prev_chars + _cur_region->gap;
			}
		}
	protected:
		folding_registry::iterator _cur_region; ///< Iterator to the next folded region.
		const folding_registry &_reg; ///< The registry for folded regions.
		size_t _region_start = 0; ///< Position of the beginning of the next folded region.
	};


	/// Used to format, measure, and assemble \ref fragment "fragments".
	class fragment_assembler {
	public:
		/// Used when the fragment should be rendered as text.
		struct text_rendering {
			/// Default constructor.
			text_rendering() = default;
			/// Initializes all fields of this struct.
			text_rendering(std::unique_ptr<ui::formatted_text> t, vec2d pos, double basecorr, colord c) :
				text(std::move(t)), topleft(pos), baseline_correction(basecorr), color(c) {
			}

			std::unique_ptr<ui::formatted_text> text; ///< The formatted text.
			vec2d topleft; ///< The top-left position of this fragment, without \ref baseline_correction.
			/// The offset to add to the result of \ref get_vertical_position() to align the baseline of all text.
			double baseline_correction = 0.0;
			colord color; ///< The color of the text.
		};
		/// Basic information about unrendered fragments.
		struct basic_rendering {
			/// Default constructor.
			basic_rendering() = default;
			/// Initializes \ref topleft.
			explicit basic_rendering(vec2d v) : topleft(v) {
			}

			vec2d topleft; ///< The top-left position of this fragment.
		};

		/// Initializes the renderer, font, and spacing.
		fragment_assembler(
			ui::renderer_base &r, str_view_t ff, double sz, double lh, double base, double tabw,
			invalid_codepoint_formatter fmt, colord invclr
		) :
			_renderer(&r), _font_family(ff), _invalid_cp_fmt(std::move(fmt)), _invalid_cp_color(invclr),
			_font_size(sz), _line_height(lh), _baseline(base), _tab_width(tabw) {
		}
		/// Initializes this struct using the given \ref contents_region.
		fragment_assembler(const contents_region &rgn, double base) : fragment_assembler(
			rgn.get_manager().get_renderer(), rgn.get_font_family(), rgn.get_font_size(), // TODO baseline should also be a property of a contents_region
			rgn.get_line_height(), base, rgn.get_tab_width(), rgn.get_invalid_codepoint_formatter(), rgn.get_invalid_codepoint_color() // TODO custom color
		) {
		}

		/// Sets \ref _xpos.
		void set_horizontal_position(double pos) {
			_xpos = pos;
		}
		/// Adds the given value to \ref _xpos.
		void advance_horizontal_position(double diff) {
			set_horizontal_position(get_horizontal_position() + diff);
		}
		/// Returns the starting horizontal position for the next fragment.
		double get_horizontal_position() const {
			return _xpos;
		}
		/// Sets \ref _line_top.
		void set_vertical_position(double pos) {
			_line_top = pos;
		}
		/// Increases the vertical position by the given number times the line height.
		void advance_vertical_position(size_t lines) {
			set_vertical_position(get_vertical_position() + lines * _line_height);
		}
		/// Returns the top position of the current line.
		double get_vertical_position() const {
			return _line_top;
		}
		/// Returns the combined result of \ref get_horizontal_position() and \ref get_vertical_position().
		vec2d get_position() const {
			return vec2d(get_horizontal_position(), get_vertical_position());
		}

		/// Does nothing but returning the current position.
		basic_rendering append(const no_fragment & frag) {
			return basic_rendering(get_position());
		}
		/// Appends a \ref text_fragment to the rendered document by calling \ref _append_text().
		text_rendering append(const text_fragment & frag) {
			return _append_text(std::basic_string_view<codepoint>(frag.text), ui::font_parameters(
				str_t(_font_family), _font_size, frag.theme.style, frag.theme.weight, ui::font_stretch::normal
			), frag.theme.color);
		}
		/// Appends a \ref tab_fragment to the rendered document.
		basic_rendering append(const tab_fragment & frag) {
			basic_rendering r(get_position());
			set_horizontal_position((std::floor(get_horizontal_position() / _tab_width) + 1.0) * _tab_width);
			return r;
		}
		/// Appends a \ref invalid_codepoint_fragment to the rendered document.
		text_rendering append(const invalid_codepoint_fragment & frag) {
			str_t textrepr = _invalid_cp_fmt(frag.value);
			return _append_text(str_view_t(textrepr), ui::font_parameters(
				str_t(_font_family), _font_size, ui::font_style::italic, ui::font_weight::normal, ui::font_stretch::normal
			), _invalid_cp_color); // TODO customizable font params
		}
		/// Appends a \ref linebreak_fragment to the rendered document by simply moving the current position.
		basic_rendering append(const linebreak_fragment & frag) {
			basic_rendering r(get_position());
			set_horizontal_position(0.0);
			advance_vertical_position(1);
			return r;
		}
		/// Appends a \ref image_gizmo_fragment to the rendered document.
		basic_rendering append(const image_gizmo_fragment & frag) {
			// TODO
			return basic_rendering(get_position());
		}
		/// Appends a \ref text_gizmo_fragment to the rendered document by calling \ref _append_text().
		text_rendering append(const text_gizmo_fragment & frag) {
			return _append_text(str_view_t(frag.contents), frag.font, frag.color);
		}

		/// Does nothing. Defined to complete the basic interface.
		void render(ui::renderer_base&, const basic_rendering&) {
		}
		/// Renders the text using the given renderer, at the position specified in the \ref text_rendering.
		/// Additional transformations may be necessary to 
		void render(ui::renderer_base & r, const text_rendering & text) {
			r.draw_formatted_text(
				*text.text, vec2d(text.topleft.x, text.topleft.y + text.baseline_correction),
				ui::generic_brush_parameters(ui::brush_parameters::solid_color(text.color))
			);
		}
	protected:
		ui::renderer_base *_renderer = nullptr; ///< The renderer.
		str_view_t _font_family; ///< The font family.
		invalid_codepoint_formatter _invalid_cp_fmt; ///< Used to format and display invalid codepoints.
		colord _invalid_cp_color; ///< The color of invalid codepoints.
		double
			_font_size = 0.0, ///< The font size.
			_line_height = 0.0, ///< The height of a line.
			_baseline = 0.0, ///< The desired base line position from the top of the line.
			_tab_width = 0.0, ///< The maximum width of a tab character.
			_line_top = 0.0, ///< The top of the current line.
			_xpos = 0.0; ///< The horizontal position, relative to the left side of the document.

		/// Appends a clip of text
		template <typename Char> text_rendering _append_text(
			std::basic_string_view<Char> text, ui::font_parameters font, colord color
		) {
			std::unique_ptr<ui::text_format> format = _renderer->create_text_format(
				font.family, font.size, font.style, font.weight, font.stretch
			);
			std::unique_ptr<ui::formatted_text> fmttext = _renderer->format_text(
				text, *format,
				vec2d(), ui::wrapping_mode::none,
				ui::horizontal_text_alignment::front, ui::vertical_text_alignment::top
			);
			std::vector<ui::formatted_text::line_metrics> lines = fmttext->get_line_metrics();
			vec2d pos = get_position();
			advance_horizontal_position(fmttext->get_layout().xmax);
			return text_rendering(std::move(fmttext), pos, _baseline - lines[0].baseline, color);
		}
	};


	/// A standalone component that gathers information about carets to be rendered later.
	struct caret_renderer {
	public:
		/// Constructs this struct with the given \ref caret_set, position, and a boolean indicating whether the last
		/// linebreak was a soft linebreak.
		caret_renderer(const caret_set::container &set, size_t pos, bool soft) : _carets(set) {
			// find the current caret
			_cur_caret = _carets.lower_bound(std::make_pair(pos, 0));
			if (_cur_caret != _carets.begin()) {
				auto prev = _cur_caret;
				--prev;
				if (prev->first.second > pos) {
					_cur_caret = prev;
				}
			}
			if (_cur_caret != _carets.end()) {
				_range = std::minmax(_cur_caret->first.first, _cur_caret->first.second);
				if (pos >= _range.first) { // midway in the selected region
					_sel_regions.emplace_back();
					_region_begin = 0.0;
					_in_selection = true;
				}
			}
			_last_is_stall = soft;
		}

		/*
		/// Called after a fragment is generated and the corresponding metrics has been updated.
		void on_update(
			const fragment_generator<> &iter, const text_metrics_accumulator &metrics,
			const fragment_generation_result &tok
		) {
			if (tok.steps > 0) { // about to move forward; this is the only chance
				_check_generate_caret(iter, metrics, tok);
				_update_selection(iter, metrics, tok.result);
				_check_generate_caret(iter, metrics, tok);
				_last_is_stall = false;
			} else { // a `stall'
				_check_generate_caret(iter, metrics, tok);
				_last_is_stall = true;
			}
			if (_in_selection && std::holds_alternative<linebreak_fragment>(tok.result)) {
				_break_selected_lines(metrics, std::get<linebreak_fragment>(tok.result));
			}
		}
		/// Called after all visible text has been laid out. This function exists to ensure that carets are rendered
		/// properly at the very end of the document.
		void finish(const fragment_generator<> &iter, const text_metrics_accumulator &metrics) {
			if (_in_selection) { // close selected region
				_sel_regions.back().emplace_back(
					_region_begin, metrics.get_character().char_right(),
					metrics.get_y(), metrics.get_y() + metrics.get_line_height()
				);
			}
			if (_cur_caret != _carets.end() && _cur_caret->first.first == iter.get_position()) {
				// render the caret that's possibly at the end of the document
				_caret_rects.emplace_back(rectd::from_xywh(
					metrics.get_character().char_right(), metrics.get_y(),
					metrics.get_character().get_font_family().normal->get_char_entry(' ').advance,
					metrics.get_line_height()
				));
			}
		}
		*/

		/// Returns the bounding boxes of all carets.
		std::vector<rectd> &get_caret_rects() {
			return _caret_rects;
		}
		/// Returns the layout of all selected regions.
		std::vector<std::vector<rectd>> &get_selection_rects() {
			return _sel_regions;
		}
	protected:
		std::vector<rectd> _caret_rects; ///< The positions of all carets.
		std::vector<std::vector<rectd>> _sel_regions; ///< The positions of selected regions.
		caret_set::const_iterator _cur_caret; ///< Iterator to the current caret.
		std::pair<size_t, size_t> _range; ///< The range of \ref _cur_caret.
		double _region_begin = 0.0; ///< Position of the leftmost border of the current selected region on this line.
		const caret_set::container &_carets; ///< The set of carets.
		bool
			_in_selection = false, ///< Indicates whether the current position is selected.
			/// Indicates whether the last fragment was a `stall', e.g., a soft linebreak or a pure gizmo.
			_last_is_stall = false;

		/*
		/// Generates a caret at the current location.
		void _generate_caret(const text_metrics_accumulator &metrics, bool linebreak) {
			if (linebreak) {
				_caret_rects.push_back(rectd::from_xywh(
					metrics.get_last_line_length(),
					metrics.get_y() - metrics.get_line_height(), // y has already been updated
					metrics.get_character().get_font_family().normal->get_char_entry(' ').advance,
					metrics.get_line_height()
				));
			} else {
				_caret_rects.push_back(rectd::from_xywh(
					metrics.get_character().char_left(), metrics.get_y(),
					metrics.get_character().char_width(), metrics.get_line_height()
				));
			}
		}
		/// Checks and generates a caret if necessary.
		void _check_generate_caret(
			const fragment_generator<> &iter, const text_metrics_accumulator &metrics,
			const fragment_generation_result &tok
		) {
			if (_cur_caret != _carets.end() && _cur_caret->first.first == iter.get_position()) {
				bool generate;
				if (tok.steps > 0) {
					generate = !_last_is_stall || _cur_caret->second.softbreak_next_line;
				} else {
					generate = !_last_is_stall && !_cur_caret->second.softbreak_next_line;
				}
				if (generate) {
					_generate_caret(metrics, std::holds_alternative<linebreak_fragment>(tok.result));
				}
			}
		}

		/// Updates selected regions, but \ref _in_selection is changed at most once. Thus this function should be
		/// called twice to obtain the correct result. \ref _cur_caret must not be past the end of the set of carets.
		///
		/// \return Indicates whether the state has been changed.
		bool _update_selection_state(
			const fragment_generator<> &it, const text_metrics_accumulator &metrics, const fragment &tok
		) {
			if (_in_selection) {
				if (it.get_position() >= _range.second) {
					// finish this region
					if (std::holds_alternative<linebreak_fragment>(tok)) {
						_sel_regions.back().emplace_back(
							_region_begin, metrics.get_last_line_length(),
							metrics.get_y() - metrics.get_line_height(), metrics.get_y()
						);
					} else {
						_sel_regions.back().emplace_back(
							_region_begin, metrics.get_character().prev_char_right(),
							metrics.get_y(), metrics.get_y() + metrics.get_line_height()
						);
					}
					// move on to the next caret
					for (++_cur_caret; _cur_caret != _carets.end(); ++_cur_caret) {
						_range = std::minmax(_cur_caret->first.first, _cur_caret->first.second);
						if (_range.second >= it.get_position()) {
							break;
						}
					}
					_in_selection = false;
					return true;
				}
			} else {
				if (it.get_position() >= _range.first) {
					// start this region
					_sel_regions.emplace_back();
					_region_begin =
						std::holds_alternative<linebreak_fragment>(tok) ?
						metrics.get_last_line_length() :
						metrics.get_character().char_left();
					_in_selection = true;
					return true;
				}
			}
			return false;
		}
		/// Updates selected regions. This function calls \ref _update_selection_state() twice.
		void _update_selection(
			const fragment_generator<> &it, const text_metrics_accumulator &metrics, const fragment &tok
		) {
			if (_in_selection && _range.second < it.get_position()) { // already past the last caret, emergency break
				// this is to prevent certain carets from disappearing
				_update_selection_state(it, metrics, tok);
			}
			if (_cur_caret != _carets.end()) {
				if (_update_selection_state(it, metrics, tok)) {
					if (_cur_caret != _carets.end()) {
						_update_selection_state(it, metrics, tok);
					}
				}
			}
		}

		/// Breaks the current selected region when a linebreak is encountered. \ref _in_selection must be \p true
		/// when this function is called.
		void _break_selected_lines(const text_metrics_accumulator &metrics, const linebreak_fragment &tok) {
			double xmax = metrics.get_last_line_length();
			if (tok.type != line_ending::none) { // hard linebreak, append a space
				xmax += metrics.get_character().get_font_family().normal->get_char_entry(' ').advance;
			}
			_sel_regions.back().emplace_back(
				_region_begin, xmax, metrics.get_y() - metrics.get_line_height(), metrics.get_y()
			);
			_region_begin = 0.0;
		}
		*/
	};
}
